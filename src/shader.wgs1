struct Globals {
  mode: u32,
  _pad0: u32,
  _pad1: u32,
  _pad2: u32,
  palette: array<vec4<f32>, 16>,
};
@group(0) @binding(0) var gridTex: texture_2d<f32>;
@group(0) @binding(1) var gridSamp: sampler;
@group(0) @binding(2) var<uniform> g: Globals;

struct VSOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32> };

@vertex
fn vs_main(@builtin(vertex_index) vi: u32) -> VSOut {
  // full-screen triangle
  var p = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -1.0),
    vec2<f32>( 3.0, -1.0),
    vec2<f32>(-1.0,  3.0)
  );
  var uv = array<vec2<f32>, 3>(
    vec2<f32>(0.0, 0.0),
    vec2<f32>(2.0, 0.0),
    vec2<f32>(0.0, 2.0)
  );

  var o: VSOut;
  o.pos = vec4<f32>(p[vi], 0.0, 1.0);
  o.uv = uv[vi];
  return o;
}

fn heat(v: f32) -> vec3<f32> {
  // simple smooth heatmap-ish curve
  let x = clamp(v, 0.0, 1.0);
  return vec3<f32>(
    smoothstep(0.2, 0.9, x),
    smoothstep(0.0, 0.7, x) * (1.0 - smoothstep(0.7, 1.0, x)),
    1.0 - smoothstep(0.0, 0.6, x)
  );
}

@fragment
fn fs_main(i: VSOut) -> @location(0) vec4<f32> {
  let v = textureSample(gridTex, gridSamp, i.uv).r; // 0..1 (R8)
  if (g.mode == 0u) {
    let idx = u32(round(v * 255.0));
    let p = g.palette[min(idx, 15u)];
    return p;
  } else {
    let c = heat(v);
    return vec4<f32>(c, 1.0);
  }
}
